//    ⠘  AKSHAT NAGPAL                ⡜
//    ⠑⡀           2022MCB1255      ⡔⠁⠀⠀⠀
// ⠀⠀⠀⠀⠈⠢⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀  ⣀⠴⠊⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⢀⣀⣀⣀⣀⣀⡀⠤⠄⠒⠈⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠘⣀⠄⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠉⢈⠩⢙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢋⠠⠀⠀⠨⠐⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⢐⠐⠌⡌⢄⢐⢈⠔⡝⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⡏⠉⡀⠐⡀⢁⠈⠐⠱⠑⡑⠈⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⢗⠀⠀⠐⡠⡛⠔⡁⢜⡔⡬⢎⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⡿⠡⠀⠀⠀⠀⠂⠁⠀⠄⢂⠈⠂⢂⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⡿⢟⠩⠐⡀⠀⠀⠀⠐⠐⠁⠓⠒⠒⢀⠁⢐⢝⢟⢿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⠫⠡⠡⠨⢀⠂⠠⠀⠀⢁⠑⡱⠛⠗⡓⢂⠠⢸⢸⢨⠣⡝⣻⣿⣿⣿⣿⣿⣿
// ⣿⢏⢐⢁⠊⢌⠐⡈⠄⠠⠀⠀⠀⠀⠁⠑⠈⠀⢄⢕⠸⡨⠪⡪⡘⣻⣿⡿⣿⣿⣿
// ⣿⢂⠂⡂⠅⡂⠅⡐⠨⢐⠐⠠⠠⡀⢄⠠⡠⡡⡱⡐⠕⢌⢊⢆⢣⢒⠽⢿⣿⣿⣿
// ⠣⢂⠂⠄⠡⠐⠐⠈⠌⡐⠨⡈⠢⠨⡂⢌⢂⠆⡪⠨⡊⠂⡂⠢⢡⣢⣣⡣⣍⢿⣿
// ⠨⢂⢂⠁⡀⠀⠀⠁⠐⠈⠐⠈⢈⠈⠐⡀⠄⠁⠌⠈⠔⣄⡀⠠⡑⡂⠆⠢⢂⠑⠽
// ⡨⠐⠀⠀⠀⢠⡎⡀⠀⠀⠄⠈⡀⠌⠐⠠⠈⠄⡁⠂⡀⡫⠑⣑⠀⢂⠌⠄⢕⠀⠨
// ⠺⡪⠢⡀⠀⠞⢇⢂⠀⠂⡀⠠⠀⠄⠁⠌⠨⠀⢄⠢⡁⢂⢿⡟⡀⠀⠈⠈⡀⠂⣰
// ⢀⢀⠀⠄⠀⠀⡐⠀⡈⠄⡐⠅⡊⠌⢌⠄⡕⡑⡁⢂⠂⢂⠸⣿⡄⠀⠈⣠⣴⣿⣿
// ⢐⠔⠠⠀⠀⡐⠠⢈⠢⢑⠄⠑⢈⠊⡂⡱⢁⣂⢌⢔⢌⢄⠀⠹⢀⣺⡿⣟⢿⣿⣿
// ⢀⠡⠁⠂⠐⠠⠈⠄⢈⠠⢈⢢⡣⣗⠕⠄⣕⢮⣞⣞⣗⣯⢯⡷⡴⣹⡪⣷⣿⣿⣿
// ⠊⠄⠠⠠⠡⠈⠠⢐⠠⡊⡎⣗⢭⢐⠹⡹⣮⡳⡵⣳⣻⢾⣻⣽⣻⣺⣺⣽⣿⣿⣿
// ⣨⣾⢐⠰⠐⠅⡂⡂⢕⢜⢜⢵⢹⢑⢔⠨⢘⠸⡹⡵⣯⣻⢽⣳⣻⣺⢞⡿⣿⣿⣿
// ⣿⣿⡔⠠⢈⠐⠐⢠⢱⢸⢸⢸⢸⠰⡡⢘⢔⢕⠝⢮⣳⢽⢝⡾⡵⡯⣏⠯⣿⣿⣿
// ⣿⣿⣗⢅⢢⠠⠡⠢⡱⡑⡕⡕⢅⠣⡊⢨⢪⡣⡣⡂⡬⡳⢽⢽⢽⢽⣞⣧⠙⣿⣿
// ⡻⣿⡯⡪⠢⡡⠡⢑⢌⠪⡪⡊⠆⢌⠪⢐⢕⢱⢱⢱⢱⢱⢙⢮⡫⡟⣞⢮⣳⠙⣿
// ⠊⣿⣯⠪⡊⠄⢅⠂⢂⠁⢇⢇⢃⠂⢕⠐⠌⡲⡰⡡⣇⠇⢇⢕⠪⠉⠂⠅⠂⡑⠹
// ⣸⢿⣳⢱⠨⡐⡽⡿⡶⡾⡬⡢⢂⠅⡢⢡⣌⠐⠈⢎⢎⢎⢔⠠⠡⠠⠠⠡⡁⡂⠡
// ⡯⡯⡇⢅⠕⠠⢱⢹⡙⢮⢹⠨⡂⡂⢇⠌⠮⡳⠅⡂⢕⠡⡑⠠⢁⢁⣡⣡⣢⣶⣿
// ⣗⢽⢌⡢⡡⡡⡸⡢⡣⡣⡱⡑⠔⡈⢎⢆⢂⠂⠅⣢⡳⣽⡐⢅⢂⣊⣿⣿⣿⣿⣿
// ⣯⢯⢷⢽⢮⢯⣺⣪⢞⡮⣳⢘⠔⢌⢜⣞⣖⣮⣻⢮⣯⢷⣿⣻⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⣿⣿⣿⣿⣾⣷⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
#include <stdio.h>         //Parental Advisory
#include <stdlib.h>       //Explicit Content

/*
Follow input format as given in example test-cases very strictly.
    Directed graphs must be initialized by inputting 'D' or 'd'.[NO SPACES]
    Undirected graphs must be initialized by inputting 'U' or 'u'.[NO SPACES]

    Edges must be enclosed by rounded brackets and the two vertices seperated by a comma and a space ", ".
    After inputting last edge, enter 'Q' or 'q' to continue to rest of the program.[NO SPACES] 
*/

typedef short bool;         //better documentation
typedef int clock;
#define true 1
#define false 0         

typedef struct global_intListType{
    int data;
    struct global_intListType *next;
}list_node;

typedef struct global_GraphClass{
    list_node **adj_list;
    bool isDirected;
    int *predecessor;
    char *colour;
    clock *discovered;
    clock *finished;
    size_t V, E;
}Graph;

typedef struct edge_information{
    int u, v;
    char type;
}edge_info;

void check_malloc(void* ptr);

void DFS(Graph* G);
void DFS_Visit(Graph* G, int vertex);

char add_edge(Graph* G);
edge_info make_edge(int u, int v, char type);
bool search_edge(int u,int v,size_t e);

void list_show(list_node *head);
void list_insert(list_node** head, int Value);

bool isBipartite(Graph* G);
bool color(Graph *G, int u, bool col);

clock time;
int e;
edge_info* Edges;

int main(void){
    Graph G;
    int i;
    printf("Enter the number of vertices: ");
    G.E = 0;
    scanf("%d", &G.V);
    getchar();

    G.adj_list = (list_node**)malloc(G.V*sizeof(list_node*));
    G.predecessor = (int*)malloc(G.V*sizeof(int));
    G.discovered = (int*)malloc(G.V*sizeof(int));
    G.finished = (int*)malloc(G.V*sizeof(int));
    G.colour = (char*)malloc(G.V*sizeof(char));
    check_malloc(G.adj_list);
    check_malloc(G.predecessor);
    check_malloc(G.discovered);
    check_malloc(G.finished);
    check_malloc(G.colour);

    for(i=0; i<G.V; i++){
        G.adj_list[i] = NULL;
        G.predecessor[i] = -1;
        G.discovered[i] = -1;
        G.finished[i] = -1;
        G.colour[i] = 'w';
    }

    printf("Your vertices are numbered from:");
    if(G.V<=5){
        for(i=0; i<G.V; i++){
            printf(" %d", i);
            printf(i==G.V-1?"\n":",");
        }
    }
    else{
        printf(" 0, 1, ..., %d\n", G.V-1);
    }

    printf("Enter D for directed or U for undirected graphs: ");
    char inp = getchar();
    getchar();
    if(inp!='D'&&inp!='d'&&inp!='U'&&inp!='u'){
        printf("invalid input(maybe extra spaces? read comments)\nexiting execution\n");
        exit(0);
    }    
    G.isDirected = (inp=='D'||inp=='d');
    inp = '*';

    printf(G.isDirected?"Enters edges one by one of your directed graph. Once done, enter 'Q':\n":"Enters edges one by one of your undirected graph. Once done, enter 'Q':\n");
    while(inp!='Q'){
        inp = add_edge(&G);
        G.E++;
    }    
    G.E--;
    Edges = (edge_info*)malloc(G.E*sizeof(edge_info));

    printf(G.isDirected?"\nYour directed graph is as follows:\n":"\nYour undirected graph is as follows:\n");
    for(i=0; i<G.V; i++){
        printf("Vertex %d: ", i);
        list_show(G.adj_list[i]);
    }

    DFS(&G);

    printf("\nVetrex\t|Discovery Time\t|Finish Time\n");
    for(i=0; i<G.V; i++){
        printf("%d\t|%d\t\t|%d\n", i, G.discovered[i], G.finished[i]);
    }

    printf("\nThe classification of Edges is as follows:\nEdge\t|\tType\n");
    for(i=0; i<G.E; i++){
        printf("(%d, %d)\t|\t", Edges[i].u, Edges[i].v);
        if(Edges[i].type=='f'){
            printf("Forward");
        }
        else if(Edges[i].type=='t'){
            printf("Tree");
        }
        else if(Edges[i].type=='b'){
            printf("Back");
        }
        else if(Edges[i].type=='c'){
            printf("Cross");
        }
        printf("\n");
    }
    printf("\n");

    if(G.isDirected){
        printf("The graph is directed.\n");
    }
    else if(!isBipartite(&G)){
        printf("The graph is not bipartite.\n");
    }
    else{
        printf("The graph is bipartite and can be coloured as:\n");
        printf("Colour 1: ");
        for(i=0; i<G.V; i++){
            if(G.colour[i]=='W'){
                printf("%d ", i);
            }
        }
        printf("\n");
        printf("Colour 2: ");
        for(i=0; i<G.V; i++){
            if(G.colour[i]=='B'){
                printf("%d ", i);
            }
        }
        printf("\n");   
    }
    return 0;
}

void check_malloc(void* ptr){
    if(ptr==NULL){
        printf("bad pointer or bad malloc\nexiting execution\n");
        exit(0);
    }
}

char add_edge(Graph* G){
    char temp;
    int u=0, v=0;
    
    temp = getchar();       
    if(temp=='Q'||temp=='q')
        return 'Q';
    scanf("%d%c%d", &u, &temp, &v);
    getchar(); getchar();
    list_insert(&G->adj_list[u], v);
    if(!G->isDirected){
        list_insert(&G->adj_list[v], u);
    }
    return '*';
}

bool search_edge(int u,int v,size_t e){
    for(int i=0; i<e; i++){
        if(Edges[i].u==u && Edges[i].v==v){
            return true;
        }
    }
    return false;
}

void list_insert(list_node** head, int Value){
    list_node* new;
    new = (list_node*)malloc(sizeof(list_node));
    check_malloc(new);

    new->data = Value;
    new->next = *head;
    *head = new;
}

void list_show(list_node *head){
    if(!head){
        printf("NIL\n");
        return;
    }
    const char* temp[]= {" -> ", "\n"};
    while(head){
        printf("%d", head->data);
        head=head->next;
        printf("%s", temp[head==NULL]);
    }
    return;
}

edge_info make_edge(int u, int v, char type){
    edge_info new;
    new.u = u;
    new.v = v;
    new.type = type;
    return new;
}

void DFS(Graph* G){
    time = e = 0;
    for(int u=0; u<G->V; u++){
        if(G->colour[u]=='w')
            DFS_Visit(G, u);
    }
}

void DFS_Visit(Graph* G, int u){
    time++;
    G->discovered[u] = time;
    G->colour[u] = 'g';
    for(list_node* x = G->adj_list[u]; x!=NULL; x=x->next){
        int v = x->data;
        if(G->colour[v] == 'w'){
            Edges[e++] = make_edge(u, v, 't');
            G->predecessor[v] = u;
            DFS_Visit(G, v);
        }
        else if(G->colour[v] == 'g'){
            if(!G->isDirected&&search_edge(v, u, e)){
                continue;
            }
            Edges[e++] = make_edge(u, v, 'b');
        }
        else{
            if(G->isDirected){
                if(G->discovered[u] < G->discovered[v]){
                    Edges[e++] = make_edge(u, v, 'f');
                }
                else{
                    Edges[e++] = make_edge(u, v, 'c');
                }
            }
        }
    }
    G->colour[u] = 'b';
    time++;
    G->finished[u] = time;
}

const char *clrs = "WB";
bool isBipartite(Graph* G){
    for(int i=0; i<G->V; i++){
        G->colour[i] = '*';
    }
    for(int i=0; i<G->V; i++){
        if(G->colour[i]=='*'&&!color(G, i, false))
            return false;
    }
    return true;
}

bool color(Graph *G, int u, bool col){
    if(G->colour[u]=='W'||G->colour[u]=='B'){
        if(G->colour[u]==clrs[col])
            return false;
        return true;
    }
    G->colour[u] = clrs[col^true];
    for(list_node* x = G->adj_list[u]; x!=NULL; x=x->next){
        int v = x->data;
        if(!color(G, v, col^true))
            return false;
    }
    return true;
}